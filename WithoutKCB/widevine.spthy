/*-------------------------------------------------------------------*/
/* Model of Widevine without KCB in the Refresh part                 */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*  - We model time using counters starting its initialization at 1  */
/*  - We use the same symbol pk for encryption and verification keys */
/*    This is unsual but reflects what happens in Widevine           */
/*                                                                   */
/*-------------------------------------------------------------------*/

theory WithoutKCB
begin

/*-------------------------------------------------------------------*/
/* Function symbols and equational theory                            */
/*-------------------------------------------------------------------*/
functions:
 enc/2, dec/2,
 aenc/2, adec/2, pk/1,
 sign/2, checksign/3, true/0, getmsg/1,
 KDF/1, hmac/2
 
builtins: natural-numbers

equations: dec(enc(x, k), k) = x
equations: adec(aenc(x, pk(k)), k) = x
equations: checksign(sign(m, k), m, pk(k)) = true
equations: getmsg(sign(m,k)) = m


/*-------------------------------------------------------------------*/
/* Protocol rules: Key generation and distribution                   */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*   - Public certificates, public keys, and signatures are          */
/*     given to the attacker                                         */
/*   - Tags are used to avoid confusion between certificates         */    
/*                                                                   */
/*-------------------------------------------------------------------*/

rule GenOTTKey: // priv0, pub0
  [  Fr(~kOTT) ]
--[  LOTTKey(~kOTT) ]->
  [ !OTTKey($ottID, ~kOTT),
     Out(pk(~kOTT)) ]

rule GenCertificate: // rootCert priv/pub
  [  Fr(~rootcert) ]
--[  LCertificate(~rootcert) ]->
  [ !Certificate(~rootcert),
     Out(pk(~rootcert)) ]

rule GenDeviceSignKey: // signer priv/pub
  [  Fr(~kSign),
    !Certificate(~rootcert) ]
--[  LDeviceSignKey(~kSign) ]->
  [ !DeviceSignKey(~kSign),
     Out(pk(~kSign)),
     Out(sign(<'root', pk(~kSign)>, ~rootcert)) ]
   
rule GenDeviceKey: // DeviceRSAKey priv/pub
  [  Fr(~kDevice),
    !DeviceSignKey(~kSign) ]
--[  LDeviceKey(~kDevice) ]->
  [ !DeviceKey(~kDevice),
     Out(pk(~kDevice)),
     Out(sign(<'device', pk(~kDevice)>, ~kSign)) ]

rule GenMovie: // Create a new movie
  [  Fr(~movie) ]
--[  LMovieGen($title, ~movie) ]->
  [ !MovieGen($title, ~movie) ]

rule GenMovieKeys: /* Create a new key for an existing movie
     (the same movie can be encrypted by different keys)*/
  [  Fr(~kContent),
     Fr(~keyID),
    !MovieGen($title, ~movie) ]
--[  LMovieKey($title, ~movie, $ottID, ~keyID, ~kContent) ]->
  [ !Movie($title, ~movie, $ottID, ~keyID, ~kContent),
     Out(~keyID) ]


/*-------------------------------------------------------------------*/
/* Protocol rules: Initialisation                                    */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*   - CDMInit: Initialises a CDM: creates a persistent              */
/*     CDMInit storing the device key and clientID for that CDM      */
/*                                                                   */
/*   - OTTInit: Initialises an OTT session (identified by a rid)     */
/*     The session is initialised for a given movie with keyID       */
/*                                                                   */
/*-------------------------------------------------------------------*/

rule CDMInit:
 let clientID =
   <$serialNumber,
    pk(~kDevice),
    sign(<'device', pk(~kDevice)>, ~kSign),
    pk(~kSign),
    sign(<'root', pk(~kSign)>, ~rootCert),
    $clientInfo>
 in
  [  Fr(~deviceID),
    !Certificate(~rootCert),
    !DeviceKey(~kDevice),
    !DeviceSignKey(~kSign) ]
--[  LCDMInit(~deviceID, ~kDevice, clientID) ]->
  [ !CDMInit(~deviceID, ~kDevice, clientID) ]


rule OTTInit:
  let initdata = <$ottID, ~keyID>
  in    
  [  Fr(~rID),
    !OTTKey($ottID, ~kOTT),
     In($title),
    !Movie($title, ~movie, $ottID, ~keyID, ~kContent) ]
--[ LOTTInit(~rID, $ottID, ~kOTT) ]->
  [ OTTInit(~rID, $ottID, ~kOTT),
    Out(initdata) ]



/*-------------------------------------------------------------------*/
/* Protocol rules: CDM                                               */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*  - CDMOpenSession: starts an initialised CDM, creates a sessionID */
/*    and a fact CDMSession storing all its data.                    */
/*                                                                   */
/*  - CDMGenerateRequest: generates a request, the facts             */
/*    CDMContentKey and CDMKeys represent the creation of the two    */
/*    memory cells used to store keys and some extra information     */
/*                                                                   */
/*  - CDMDerive: derives Kenc and KMac keys from session keys        */
/*                                                                   */
/*  - CDMLoad: loads the contentKey received in the response         */
/*    from the OTT.                                                  */
/*                                                                   */
/*  - CDMGenerateRefreshRequest: generates a refresh request         */
/*                                                                   */
/*  - CDMLoadRefresh: handles refresh response and                   */
/*    refresh content key                                            */
/*                                                                   */
/*  - CDMUseKey: uses the key to read the movie.                     */
/*    This rule comes with a "Tamarin restriction" UseKeyLegal       */
/*    whose purpose is to check that this is indeed legal, from the  */
/*    timing point of view, to use the key.                          */
/*                                                                   */
/*-------------------------------------------------------------------*/


/* CDMSession is persistent, so that other rules may be called
   any number of times in that session afterwards. */
/* Note that we do not model the "setting the OTT key" part. 
   The fact OTTKey is used directly in the CDMGenerateRequest rule instead */
rule CDMOpenSession:
  [  Fr(~sessionID),
    !CDMInit(~deviceID, kDevice, clientID) ]
--[  LCDMOpenSession(~sessionID, ~deviceID, kDevice) ]->
  [ !CDMSession(~sessionID, ~deviceID, kDevice, clientID),
     Out(~sessionID)]


rule CDMGenerateRequest:
let request =<~requestID,
              ~keyID,
              %t,
              enc(<'clientID', clientID>, ~kPrivacy),
              aenc(~kPrivacy, pk(~kOTT)),
              ~nonce>
    signReq = sign(<'newreqTag', request>, kDevice)
in
  [  In(%t),
     In(~keyID), // the attacker may choose the movie he wants
    !CDMSession(~sessionID, ~deviceID, kDevice, clientID),
    !OTTKey($ottID, ~kOTT),
     Fr(~nonce),
     Fr(~requestID),
     Fr(~kPrivacy) ]
--[  GTime(%t),
     LCDMGenerateRequest(~requestID, ~sessionID, ~deviceID, %t) ]->
  [  Out(<request, signReq>),
     CDMNonce(~nonce, ~sessionID, ~deviceID),
    !CDMState(~requestID, ~sessionID, ~deviceID, $ottID, ~kOTT, request, %t),
     CDMKeys(~requestID, ~sessionID, ~deviceID, 'null', 'null', 'null'),
     CDMContentKey(~requestID, ~sessionID, ~deviceID,
                   'null', 'null', 'null','null', 'null','null', %1) ] 
     

/* CDM Derive keys from session keys */
rule CDMDerive:
  let
    pkDevice = pk(kDevice)
    enc_kSession = aenc(kSession, pkDevice)
    enc_context = <'encryption', request>
    mac_context = <'authentication', request>
    kEnc = KDF(<enc_context, kSession>)
    kMacS = KDF(<<'S', mac_context>, kSession>)
    kMacC = KDF(<<'C', mac_context>, kSession>)
  in
  [ !CDMSession(~sessionID, ~deviceID, kDevice, clientID),
    !CDMState(~requestID, ~sessionID, ~deviceID, $ottID, ~kOTT, request, %t),
     CDMKeys(~requestID, ~sessionID, ~deviceID, xundef1, xundef2, xundef3),
     In(enc_kSession),
     In(~requestID) ] // actually the whole response,
                      // but only requestID is useful
--[  LCDMDerive(~requestID, ~sessionID, ~deviceID,
                kDevice, clientID, kEnc, kMacS, kMacC),
     LCDMDeriveKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC), 
     LCDMSessionKey(kSession) ]->
  [  CDMKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC) ]



/* The counter is left unchanged when loading,
   as we do not know whether it should be reinitialised or not. */
/* The time %t1 stored in the fact CDMContentKey is the one received
   in the response, and  the CDM checks that this is exactly the time
   at which it generates its request (cf. CDMState) */
/* Note that the KCB also contains the information regarding the delta,
   but it is not checked and not really used, thus we call it deltaBis */
/* In reality, the CDM computes the time during which it can use the key
   as follows: delta - (t - t1), i.e. the OTT gives it delta units of time
   starting at time t1, 
   since the CDM loads this response at time t, it remains delta - (t-t1) units
   of time. Instead of doing this computation, we simply store %t1 and $delta */
/* The values %t1 and %delta stored in the fact CDMContentKey tell us
   that the key can be used until %t1 + %delta. Note that this is equal to
   the use of the key delta - (t-t1) units of time starting from t. */
rule CDMLoad:
  let
    enc_kContent = enc(kContent, kEnc)
    KCB = <%deltaBis, usage, ~n>
    enc_KCB = enc(KCB, kContent)
    response = <~requestID,
                %t1,
                %delta,
                licencePolicy,
                keyID,
                enc_kContent,
                enc_KCB>
    mac = hmac(<'loadTag', response>, kMacS)
  in
  [  In(%t),
    !CDMSession(~sessionID, ~deviceID, kDevice, clientID),
    !CDMState(~requestID, ~sessionID, ~deviceID, $ottID, ~kOTT, request, %t1), 
     CDMNonce(~n, ~sessionID, ~deviceID), // consume the nonce
     CDMKeys(~requestID,~sessionID, ~deviceID, kEnc, kMacS, kMacC),
     CDMContentKey(~requestID, ~sessionID, ~deviceID,
                   xkeyID, xkContent, xusage, xpolicy, xt, xdelta1, %xcpt),
     In(response),
     In(mac) ]
--[  GTime(%t),
     LCDMLoad(~requestID, ~sessionID, ~deviceID, kDevice, clientID,
              kContent, kEnc, kMacS, kMacC, response),
     LCDMContentKey(~requestID, ~sessionID, ~deviceID,
                    keyID, kContent, usage, licencePolicy, %t1, %delta, %xcpt),
     LCDMKeys(~requestID,~sessionID, ~deviceID, kEnc, kMacS, kMacC) ]->
  [  CDMKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC),
     CDMContentKey(~requestID, ~sessionID, ~deviceID,
                   keyID, kContent, usage, licencePolicy, %t1, %delta, %xcpt) ] 


/* This operation is done at global time %t whereas the initial request
   was done at time %t1, both time appear in the refresh request */
/* Note that we do not store %t, the time at which the refresh request
   has been done, since no check will be performed on it when the response
   is received. */
rule CDMGenerateRefreshRequest:
  let
    renewal_request = <~requestID,
                       %t1,
                       %t,
                       %counter,
                       'renewable',
                       enc(<'clientID', clientID>, ~kPrivacyR),
                       aenc(~kPrivacyR, pk(~kOTT))>
    macrequest = hmac(<'renewreqTag', renewal_request>, kMacC)
   in
  [  In(%t),
    !CDMSession(~sessionID, ~deviceID, kDevice, clientID),
    !CDMState(~requestID, ~sessionID, ~deviceID, $ottID, ~kOTT, request, %t1),
     CDMKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC),
     Fr(~kPrivacyR),
     CDMContentKey(~requestID, ~sessionID, ~deviceID, keyID,
                   kContent, usage, 'renewable', %xt, %xdelta, %counter) ]
--[  GTime(%t),
     LCDMGenerateRefreshRequest(~requestID, ~sessionID, ~deviceID,
                                %t1, kEnc, kMacS, kMacC),
     LCDMContentKey(~requestID, ~sessionID, ~deviceID, keyID,
                    kContent, usage, 'renewable', %xt, %xdelta, %counter),
     LCDMContentKeyNoLoad(~requestID, ~sessionID, ~deviceID, keyID,
                          kContent, usage, 'renewable', %xt, %xdelta, %counter),

     LCDMKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC) ]->
  [  Out(<renewal_request, macrequest>),
     CDMKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC),
     CDMContentKey(~requestID, ~sessionID, ~deviceID, keyID,
                   kContent, usage, 'renewable', %xt, %xdelta, %counter) ]
  

/* This load refresh operation is performed at global time %t
   whereas the generateRefreshRequest operation was done at time %t2Recv,
   and the original generateRequest at %t1Recv */
/* The response received by the CDM includes a counter whose value
   %counter + %x has to be strictly larger than the one store until now */
/* Note that the CDM does not check that t1 is equal to t1Recv
   (as done e.g. in the initial load */
/* In reality, the CDM computes the time during which it can use the key
   as follows: delta - (t - t2Recv) starting at time t (the current time),
   this means that the OTT gives it delta units of time,
   starting at time t2Recv.
   Instead of doing this computation, we simply store %t2Recv and $delta */
/* The values %t2Recv and %delta stored in the fact CDMContentKey tell us
   that the key can be used until %t2Recv + %delta */
rule CDMLoadRefresh:
  let renewal_response = <~requestID,
                          %t1Recv,
                          %t2Recv, 
                          %counter %+ %x,
                          new_licencePolicy,
                          %delta> 
    mac = hmac(<'renewTag', renewal_response>, kMacS)
  in
  [  In(%t),
    !CDMSession(~sessionID, ~deviceID, kDevice,  clientID),
    !CDMState(~requestID, ~sessionID, ~deviceID, $ottID, ~pkOTT, request, %t1), 
     CDMKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC),
     CDMContentKey(~requestID, ~sessionID, ~deviceID, keyID,
                   kContent, usage, licencePolicy, %t2, xdelta, %counter),
     In(renewal_response),
     In(mac) ]
--[  GTime(%t),
     LCDMLoadRefresh(~requestID, ~sessionID, ~deviceID, kDevice,
                     clientID, kContent, kEnc, kMacS, kMacC,
                     renewal_response, licencePolicy),
     LCDMContentKey(~requestID, ~sessionID, ~deviceID, keyID,
                    kContent,usage, new_licencePolicy,
                    %t2Recv, %delta, %counter %+ %x),
     LCDMContentKeyNoLoad(~requestID, ~sessionID, ~deviceID, keyID,
                          kContent, usage, new_licencePolicy,
                          %t2Recv, %delta, %counter %+ %x),
     LCDMContentKeyInc(~requestID, ~sessionID, ~deviceID, keyID,
                       kContent, usage, new_licencePolicy,
                       %t2Recv, %delta, %counter %+ %x),
     LCDMKeys(~requestID,~sessionID, ~deviceID, kEnc, kMacS, kMacC) ]->
  [  CDMKeys(~requestID, ~sessionID, ~deviceID, kEnc, kMacS, kMacC),
     CDMContentKey(~requestID,~sessionID, ~deviceID, keyID,
                   kContent, usage, new_licencePolicy,
                   %t2Recv, %delta, %counter %+ %x) ]


/* CDM uses the key to read the movie. */
/* tag must be 'use' */
/* This operation is performed at time t, and we have to check that
   this use is authorised at time %t from the point of view of the CDM, 
   i.e. %t < %t2 + %delta -- this is imposed by the restriction written
   just below the rule */
rule CDMUseKey:
  [  In(%t),
     In(enc(<'movietag', m>, kContent)),
     CDMContentKey(~requestID, ~sessionID, ~deviceID, keyID, kContent,
                   'use', licencePolicy, %t2, %delta, %xcpt) ]
--[  GTime(%t),
     LCDMUseKey(~requestID, ~sessionID, ~deviceID, keyID, kContent),
     LCDMContentKey(~requestID, ~sessionID, ~deviceID, keyID,
                    kContent, 'use', licencePolicy, %t2, %delta, %xcpt),
     LCDMContentKeyNoLoad(~requestID, ~sessionID, ~deviceID, keyID,
                          kContent, 'use', licencePolicy,
                          %t2, %delta, %xcpt) ]->
  [  CDMContentKey(~requestID, ~sessionID, ~deviceID, keyID,
                   kContent, 'use', licencePolicy, %t2, %delta, %xcpt) ]


restriction UseKeyLegal:
  "All #i requestID sessionID deviceID keyID
          kContent %t usage licencePolicy %t2 %delta xcpt.
     LCDMUseKey(requestID, sessionID, deviceID, keyID, kContent)@i &
     LCDMContentKey(requestID, sessionID, deviceID, keyID,
                    kContent, usage, licencePolicy, %t2, %delta, xcpt)@i &
     GTime(%t)@i
   ==>
     %t << %t2 %+ %delta"



/*-------------------------------------------------------------------*/
/* Protocol rules: OTT                                               */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*  - OTTLicenseResponse: Response to initial request by OTT.        */
/*                                                                   */
/*  - OTTRefreshResponse: Response by OTT to refresh request         */
/*                                                                   */
/*  Regarding the licence policy, in both cases, the OTT has to      */
/*  decide whether the key is still 'renewable' or not.              */
/*  Both situations are modeled using a "Tamarin restriction" named  */
/*  LicenceRenewOrStop.                                              */
/*                                                                   */
/*  - OTTSendMovie: OTT sends a movie encrypted by its content key   */
/*                                                                   */
/*-------------------------------------------------------------------*/

/* The request received by the OTT contains the time %t1
   at which the request by the CDM has been performed */
/* This time %t1 is also part of the response, and the OTT fixes %delta,
   the period during which the CDM will be able
   to use the key starting at t1.
   In our model this period is fixed by the attacker */
rule OTTLicenseResponse:
  let
    pkDevice = pk(kDevice)
    clientID = <$serialNumber,
                pkDevice, sign(<'device', pkDevice>, kSign),
                pk(kSign), sign(<'root', pk(kSign)>, ~rootCert),
                $clientInfo>
    request = <requestID, ~keyID, %t1,
               enc(<'clientID', clientID>, kPrivacy),
               aenc(kPrivacy, pk(~kOTT)),
               n>
    signReq = sign(<'newreqTag', request>, kDevice)
    kEnc = KDF(<<'encryption', request>, ~kSession>)
    kMacS = KDF(<<'S', <'authentication', request>>, ~kSession>)
    kMacC = KDF(<<'C', <'authentication', request>>, ~kSession>)
    response = <requestID, 
                %t1,
                %delta,
                $newlicence, 
                ~keyID,
                enc(~kContent, kEnc),
                enc(< %delta, 'use', n>, ~kContent)>
    mac = hmac(<'loadTag', response>, kMacS)
    enc_kSession = aenc(~kSession, pkDevice)
  in
  [  In(%delta),
     OTTInit(~rID, $ottID, ~kOTT),
    !Certificate(~rootCert),
    !Movie($title, ~movie, $ottID, ~keyID, ~kContent),
     In(<request, signReq>),
     Fr(~kSession) ]
--[  LOTTLicenseResponse(~rID, $ottID, ~kOTT, requestID,
                         ~kContent, kEnc, kMacS, kMacC, response),
     LOTTAuthorise(requestID, $ottID, %t1, %delta),
     LOTTkDeviceKey(kDevice),
     Licence($newlicence),
     LSessionKey(~kSession) ]->
  [  OTT2_response(~rID, $ottID, ~kOTT, requestID,
                   ~kContent, kEnc, kMacS, kMacC),
     Out(<response, mac, enc_kSession>) ]


/* Response by OTT to refresh request */
/* The refresh request received by the OTT contains the time %t1
   at which the initial request has been done by the CDM, 
   as well as the time $t2 at which this refresh request has been done. */
/* The time %t1 and %t2 are includes in the response, and the OTT fixes %delta,
   the period during which the CDM is authorised to use the key
   (starting at %t2) */  
/* The response contains also %counter + 1, i.e. the counter received
   in the request has been incremented by 1 */
rule OTTRefreshResponse:
  let
    pkDevice = pk(kDevice)
    clientID = <$serialNumber,
                pkDevice, sign(<'device', pkDevice>, kSign),
                pk(kSign), sign(<'root', pk(kSign)>, ~rootCert),
                $clientInfo>
    request = <requestID,
               %t1,
               %t2,
               %counter,
               'renewable',
               enc(<'clientID',clientID>, kPrivacyR),
               aenc(kPrivacyR, pk(~kOTT))>
    macrequest = hmac(<'renewreqTag', request>, kMacC)
    response = <requestID,
                %t1,
                %t2,
                %counter %+ %1,
                $newlicence,
                %delta>
    macresponse = hmac(<'renewTag', response>, kMacS)
  in
  [  In(%delta),
     OTT2_response(~rID, $ottID, ~kOTT, requestID,
                   kContent, kEnc, kMacS, kMacC),
    !Certificate(~rootCert),
     In(<request, macrequest>) ]
--[  LOTTAuthorise(requestID, $ottID, %t2, %delta),
     LOTTRefreshResponse(~rID, $ottID, ~kOTT, requestID,
                         kContent, kEnc, kMacS, kMacC, response), 
     Licence($newlicence) ]->
  [  OTT2_response(~rID, $ottID, ~kOTT, requestID,
                   kContent, kEnc, kMacS, kMacC),
     Out(<response, macresponse>) ]


restriction LicenceRenewOrStop:
  "All #i  newLicence.
     Licence(newLicence)@i
   ==>
     (newLicence = 'renewable' | newLicence = 'stop')"


rule OTTSendMovie:
  [ !Movie($title, ~movie, $ottID, ~keyID, ~kContent) ]
-->
  [  Out(enc(<'movietag', ~movie>, ~kContent)) ]



/*-------------------------------------------------------------------*/
/* Restrictions + helping lemmas                                     */
/*-------------------------------------------------------------------*/

/* We assume the there is only one root certificate */
restriction UniqueRootCert:
  "All #i #j xi xj.
     LCertificate(xi)@i & LCertificate(xj)@j ==> #i = #j"

/* Time is increasing */
 restriction TimeIncreasing:
  "All #i #j %t1 %t2.
     GTime(%t1)@i & GTime(%t2)@j & i < j ==> %t1 << %t2"

/* OTTRefreshResponse => OTTLicenceResponse */
lemma OTT2 [use_induction, reuse]:
  "All #i rID ottID kOTT requestID
          kContent kEnc kMacS kMacC renewal_resp.
     LOTTRefreshResponse(rID, ottID, kOTT, requestID,
                         kContent, kEnc, kMacS, kMacC, renewal_resp)@i
   ==> 
     Ex #j response.
       (LOTTLicenseResponse(rID, ottID, kOTT, requestID,
                            kContent, kEnc, kMacS, kMacC, response)@j &
        #j < #i)"

/*-------------------------------------------------------------------*/
/* Lemmas: Secrecy                                                   */
/*-------------------------------------------------------------------*/
/* lemmas about secrecy of the keys -
   all are easy to establish and are marked "reuse"
   as they could be useful to establish other lemmas */

#ifdef Secrecy

/* Secrecy of device (private) keys */
lemma kDeviceSecrecy[reuse]:
  "All #i kDevice.
     LDeviceKey(kDevice)@i ==>
     not (Ex #j. K(kDevice)@j)"

/* Secrecy of OTT (private) keys */
lemma kOTTSecrecy[reuse]:
  "All #i kOTT.
     LOTTKey(kOTT)@i ==>
     not (Ex #j. K(kOTT)@j)"

/* Secrecy of device signing keys */
lemma kDeviceSignSecrecy[reuse]:
  "All #i kSign.
     LDeviceSignKey(kSign)@i ==>
     not (Ex #j. K(kSign)@j)"

/* Secrecy of private certificates */
lemma kCertificateSecrecy[reuse]:
  "All #i cert.
     LCertificate(cert)@i ==>
     not (Ex #j. K(cert)@j)"

/* Secrecy of session keys (with KU) */
lemma kSessionKeySecrecyKU[reuse]:
  "All #i kSession.
     LSessionKey(kSession)@i ==>
     not (Ex #j. KU(kSession)@j)"

/* Secrecy of session keys (with K) */
lemma kSessionKeySecrecyK[reuse]:
  "All #i kSession.
     LSessionKey(kSession)@i ==>
     not (Ex #j. K(kSession)@j)"

/* Secrecy of content keys (with KU) */
lemma contentKeySecrecyKU[reuse]:
  "All #i title movie ottID keyID kContent.
     LMovieKey(title, movie, ottID, keyID, kContent)@i ==>
     not (Ex #j. KU(kContent)@j)"

/* Secrecy of device (private) keys from the point of view of the OTT */
 lemma OTTkDeviceSecrecyKU[reuse]:
  "All #i kDevice.
    LOTTkDeviceKey(kDevice)@i ==>
    not (Ex #j. KU(kDevice)@j)"

#endif

/*-------------------------------------------------------------------*/
/* Lemma: Goal 1 - Content Key secrecy                               */
/*-------------------------------------------------------------------*/

#ifdef Goal1

lemma contentKeySecrecyK:
  "All #i title movie ottID keyID kContent.
     LMovieKey(title, movie, ottID, keyID, kContent)@i ==>
     not (Ex #j. K(kContent)@j)"


#endif

/*-------------------------------------------------------------------*/
/* Lemma: Goals 2, 3, and 4 about Initial Request/Response           */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*  - Goal 2 (integrity): OTTLicenseResponseBeforeLoad               */
/*                                                                   */
/*  - Goal 3 (unicity): LoadRespUnique                               */
/*                                                                   */
/*  - Goal 4 (time): UseAuthorised                                   */
/*                                                                   */
/*-------------------------------------------------------------------*/

#ifdef GoalInitialPart


/* Helping lemma:
   useful to know that macKeys that are not null have been
   instantiated using Derive, and thus have a certain shape */
/* Note that the fact LCDMKeys labels neither the
   CDMGenerateRequest rule, nor the CDMDerive rule */
lemma CDMKeysInit[reuse, use_induction]:
  "All #i requestID deviceID sessionID kEnc kMacS kMacC.
     LCDMKeys(requestID, sessionID, deviceID, kEnc, kMacS, kMacC)@i
   ==>
     ((Ex #j.
         (#j < #i ) &
         LCDMDeriveKeys(requestID, sessionID, deviceID, kEnc, kMacS, kMacC)@j) |
      (kEnc ='null' & kMacS = 'null' & kMacC = 'null'))"



/* When a load of a response happens in the CDM
   (for a legitimate content key), this response comes indeed from an OTT */
lemma OTTLicenseResponseBeforeLoad[reuse]:
  "All #i1 #i2 deviceID kDevice clientID requestID sessionID
               kContent kEnc kMacS kMacC response title movie ottID keyID. 
     LCDMLoad(requestID, sessionID, deviceID,
              kDevice, clientID, kContent, kEnc, kMacS, kMacC, response)@i1 &
     LMovieKey(title, movie, ottID, keyID, kContent)@i2
   ==>
    (Ex #j rID kOTT. 
        LOTTLicenseResponse(rID, ottID, kOTT, requestID,
                            kContent, kEnc, kMacS, kMacC, response)@#j & 
        #j < #i1)"


/* A load of a given reponse can happen only once in the CDM */
lemma LoadRespUnique:
  "All #i1 requestID1 deviceID1 kDevice1 clientID1 sessionID1
           kContent1 kEnc1 kMacS1 kMacC1 response
       #i2 requestID2 deviceID2 kDevice2 clientID2 sessionID2
           kContent2 kEnc2 kMacS2 kMacC2.
     LCDMLoad(requestID1, sessionID1, deviceID1, kDevice1, clientID1,
              kContent1, kEnc1, kMacS1, kMacC1, response)@i1 &
     LCDMLoad(requestID2, sessionID2, deviceID2, kDevice2, clientID2,
              kContent2, kEnc2, kMacS2, kMacC2, response)@i2
   ==>
     #i1 = #i2"


/* helping lemma for establishing the UseAuthorised lemma below */
lemma CDMContentKeyAuthorised[use_induction, reuse]:
  "All #i requestID sessionID deviceID keyID kContent usage licencePolicy
          %t %delta %counter
       #i2 title movie ottID.
     LCDMContentKey(requestID, sessionID, deviceID, keyID,
                    kContent, usage, licencePolicy, %t, %delta, %counter)@i &
     not( Ex #j sessionIDBis deviceIDBis kDeviceBis clientIDBis
                kContentBis kEncBis kMacSBis kMacCBis
                renewal_responseBis oldPolicy.
             (#j < #i | #j=#i)  &
             LCDMLoadRefresh(requestID,sessionIDBis,deviceIDBis, kDeviceBis,
                             clientIDBis, kContentBis,
                             kEncBis, kMacSBis, kMacCBis,
                             renewal_responseBis, oldPolicy)@j) &
     LMovieKey(title, movie, ottID, keyID, kContent)@i2
   ==>
     Ex #j.
        LOTTAuthorise(requestID, ottID, %t, %delta)@j &
        j < i"


/* When a legitimate content key is used at time t (and assuming that no load refresh has been done), 
then this usage has been authorised by the OTTT (in particular the timing constraint is met) */
lemma UseAuthorised:
  "All #i requestID sessionID deviceID keyID kContent %t
       #i2 title movie ottID .
     LCDMUseKey(requestID, sessionID, deviceID, keyID, kContent)@i & 
     not( Ex #j sessionIDBis deviceIDBis kDeviceBis clientIDBis
                kContentBis kEncBis kMacSBis kMacCBis
                renewal_responseBis oldPolicy.
             (#j < #i | #j =#i) &
             LCDMLoadRefresh(requestID,sessionIDBis,deviceIDBis, kDeviceBis,
                             clientIDBis, kContentBis,
                             kEncBis, kMacSBis, kMacCBis,
                             renewal_responseBis, oldPolicy)@j) &
    GTime(%t)@i &
    LMovieKey(title, movie, ottID, keyID, kContent)@i2
  ==>
    Ex #j %t1 %delta.
       LOTTAuthorise(requestID, ottID, %t1, %delta)@j &
       j < i &
       %t << %t1 %+ %delta"

#endif


/*-------------------------------------------------------------------*/
/* Lemma: Goals 5, 6, 7, 8 about Refresh Request/Response            */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*  - Goal 5 (integrity): OTTRefreshResponseBeforeLoadRefresh        */
/*      -> does not hold -- see attack                               */
/*                                                                   */
/*  - Goal 6 (unicity): LoadRefreshRespUnique                        */
/*      -> verified                                                  */
/*                                                                   */
/*  - Goal 7 (time): UseAuthorised                                   */
/*      -> does not hold due to the attack on Goal 5                 */
/*                                                                   */
/*  - Goal 8 (bonus): LoadRefreshOnlyIfRenewable                     */
/*      -> does not hold due to the attack on Goal 5                 */
/*                                                                   */
/*-------------------------------------------------------------------*/


#ifdef Goal6

/* Helping lemma */
lemma  counterIncrease[use_induction, reuse]:
  "All #j1 requestID sessionID1 deviceID1 keyID1 kContent1
           usage1 policy1 t1 delta1 cpt1
       #j2           sessionID2 deviceID2 keyID2 kContent2
           usage2 policy2 t2 delta2 cpt2.
     LCDMContentKey(requestID, sessionID1, deviceID1, keyID1,
                    kContent1, usage1, policy1, t1, delta1, cpt1)@j1 &
     LCDMContentKey(requestID, sessionID2, deviceID2, keyID2,
                    kContent2, usage2, policy2, t2, delta2, cpt2)@j2 &
     #j1 < #j2
   ==>
     not(cpt2 << cpt1)"


/* Note: the proof is a bit long */
lemma counterIncreaseStrict[reuse]:
  "All #j1 requestID sessionID1 deviceID1 keyID1 kContent1
           usage1 policy1 t1 delta1 cpt1
       #j2           sessionID2 deviceID2 keyID2 kContent2
           usage2 policy2 t2 delta2 cpt2.
     LCDMContentKey(requestID, sessionID1, deviceID1, keyID1,
                    kContent1, usage1, policy1, t1, delta1, cpt1)@j1 &
     LCDMContentKeyInc(requestID, sessionID2, deviceID2, keyID2,
                       kContent2, usage2, policy2, t2, delta2, cpt2)@j2 &
     #j1 < #j2
   ==>
     cpt1 << cpt2"


/* Goal 6 */
/* Due to the fact that the counter is stricly increasing when performing
   a Loadrefresh, we are now able to establish Goal 6 */
lemma LoadRefreshRespUnique:
  "All #i1 requestID deviceID1 kDevice1 clientID1 sessionID1 kContent1
           kEnc1 kMacS1 kMacC1 requestID1 tinit1 t1 counter licencePolicy1
           delta1 oldPolicy1
       #i2 deviceID2 kDevice2 clientID2  sessionID2 kContent2
           kEnc2 kMacS2 kMacC2 requestID2 tinit2 t2 licencePolicy2
           delta2 oldPolicy2.
     LCDMLoadRefresh(requestID, sessionID1, deviceID1, kDevice1,
                     clientID1, kContent1,
                     kEnc1, kMacS1, kMacC1,
                     <requestID1, tinit1, t1, counter, licencePolicy1, delta1>,
                     oldPolicy1)@i1 &
     LCDMLoadRefresh(requestID, sessionID2, deviceID2, kDevice2,
                     clientID2, kContent2,
                     kEnc2, kMacS2, kMacC2,
                     <requestID2, tinit2, t2, counter, licencePolicy2, delta2>,
                     oldPolicy2)@i2 
   ==>
     #i1 = #i2"

#endif


#ifdef Goal578

/* The lemma below is Goal 5,
   and there is an attack on it - The Derive attack */
/* Roughly, it is possible to load a content key using some kEnc/KMac,
   and then derive new keys kEnc'/KMac' known by the attacker.
   The attacker will be able to forge the response using these keys
   (the OTT is not needed), and the CDM will accept this load refresh. */

/* In order to help Tamarin to retrieve the attack we add some restrictions
   to reduce the size of the search space */

/* Rule GenDeviceSignKey is called at most once */
restriction onlyOnceDeviceSignKey:
  "All #i1 kSign1 #i2 kSign2.
     LDeviceSignKey(kSign1)@i1 &
     LDeviceSignKey(kSign2)@i2
   ==>
     #i1 = #i2" 

/* Rule GenDeviceKey is called at most once */
restriction onlyOnceDeviceKey:
  "All #i1 kDevice1 #i2 kDevice2.
     LDeviceKey(kDevice1)@i1 &
     LDeviceKey(kDevice2)@i2
   ==>
     #i1 = #i2" 

/* Rule GenOTTKey is called at most once */
restriction onlyOnceOTTKey:
  "All #i1 kOTT1 #i2 kOTT2.
     LOTTKey(kOTT1)@i1 &
     LOTTKey(kOTT2)@i2
   ==>
     #i1 =#i2"

/* Rule GenMovieKeys is called at most once */
restriction onlyOnceMovie:
  "All #i1 title1 movie1 ottID1 keyID1 kContent1
       #i2 title2 movie2 ottID2 keyID2 kContent2.
     LMovieKey(title1, movie1, ottID1, keyID1, kContent1)@i1 &
     LMovieKey(title2, movie2, ottID2, keyID2, kContent2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMInit is called at most once */
restriction onlyOnceCDMInit:
  "All #i1 deviceID1 kDevice1 clientID1
       #i2 deviceID2 kDevice2 clientID2. 
     LCDMInit(deviceID1, kDevice1, clientID1)@i1 &
     LCDMInit(deviceID2, kDevice2, clientID2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMOpenSession is called at most once */
restriction onlyOnceOpenSession:
  "All #i1 deviceID1 sessionID1 kDevice1
       #i2 deviceID2 sessionID2 kDevice2.
     LCDMOpenSession(sessionID1, deviceID1, kDevice1)@i1 &
     LCDMOpenSession(sessionID2, deviceID2, kDevice2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMGenerateRequest/CDMGenerateRSASignature is called at most once */
restriction onlyOnceCDMGenerateRequest:
  "All #i1 deviceID1 sessionID1 requestID1 t1
       #i2 deviceID2 sessionID2 requestID2 t2.
     LCDMGenerateRequest(requestID1, sessionID1, deviceID1, t1)@i1 &
     LCDMGenerateRequest(requestID2, sessionID2, deviceID2, t2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMLoad/CDMLoadLow is called at most once */
restriction onlyOnceCDMLoad:
  "All #i1 deviceID1 kDevice1 clientID1 requestID1 sessionID1 kContent1
           kEnc1 kMacS1 kMacC1 response1 
       #i2 deviceID2 kDevice2 clientID2 requestID2 sessionID2 kContent2
           kEnc2 kMacS2 kMacC2 response2. 
     LCDMLoad(requestID1, sessionID1, deviceID1, kDevice1, clientID1,
              kContent1, kEnc1, kMacS1, kMacC1, response1)@i1 &
     LCDMLoad(requestID2,sessionID2, deviceID2, kDevice2, clientID2,
              kContent2, kEnc2, kMacS2, kMacC2, response2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMGenerateRefresh/CDMGenerateSignature is called at most once */
restriction onlyOnceCDMGenerateRefreshRequest:
  "All #i1 deviceID1 sessionID1 requestID1 t1 kEnc1 kMacS1 kMacC1 
       #i2 deviceID2 sessionID2 requestID2 t2 kEnc2 kMacS2 kMacC2.
     LCDMGenerateRefreshRequest(requestID1, sessionID1, deviceID1, t1,
                                kEnc1, kMacS1, kMacC1)@i1 &
     LCDMGenerateRefreshRequest(requestID2, sessionID2, deviceID2, t2,
                                kEnc2, kMacS2, kMacC2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMLoadRefresh/CDMLoadRefreshLow is called at most once */
restriction onlyOnceCDMLoadRefresh:
  "All #i1 deviceID1 kDevice1 clientID1 requestID1 sessionID1
           kContent1 kEnc1 kMacS1 kMacC1 rr1 oldPolicy1
       #i2 deviceID2 kDevice2 clientID2 requestID2 sessionID2
           kContent2 kEnc2 kMacS2 kMacC2 rr2 oldPolicy2.
    LCDMLoadRefresh(requestID1, sessionID1, deviceID1, kDevice1, clientID1,
                    kContent1, kEnc1, kMacS1, kMacC1, rr1, oldPolicy1)@i1 &
    LCDMLoadRefresh(requestID2, sessionID2, deviceID2, kDevice2, clientID2,
                    kContent2, kEnc2, kMacS2, kMacC2, rr2, oldPolicy2)@i2
  ==>
    #i1 = #i2"


/* Rule CDMUseKey is not used */
restriction noCDMUseKey:
  "All #i requestID sessionID deviceID keyID kContent.
     LCDMUseKey(requestID, sessionID, deviceID, keyID, kContent)@i
   ==>
     F"

/* Rule InitOTT is called at most once */
restriction onlyOnceOTTInit:
  "All #i1 rID1 ottID1 kOTT1
       #i2 rID2 ottID2 kOTT2. 
     LOTTInit(rID1, ottID1, kOTT1)@i1 &
     LOTTInit(rID2, ottID2, kOTT2)@i2
   ==>
     #i1 = #i2"

/* Rule OTTLicenceResponse is called at most once */
restriction onlyOnceOTTLicenseResponse:
  "All #i1 rID1 ottID1 kOTT1 requestID1 kContent1
           kEnc1 kMacS1 kMacC1 response1 
       #i2 rID2 ottID2 kOTT2 requestID2 kContent2
           kEnc2 kMacS2 kMacC2 response2.
     LOTTLicenseResponse(rID1, ottID1, kOTT1, requestID1,
                         kContent1,  kEnc1, kMacS1, kMacC1, response1)@i1 &
     LOTTLicenseResponse(rID2, ottID2, kOTT2, requestID2,
                         kContent2,  kEnc2, kMacS2, kMacC2, response2)@i2
   ==>
     #i1 = #i2"


/* Goal 5 is as follows */
lemma OTTRefreshResponseBeforeLoadRefresh:
  "All #i1 #i2 deviceID kDevice clientID requestID sessionID kContent
               kEnc kMacS kMacC resp title movie ottID keyID oldPolicy. 
     LCDMLoadRefresh(requestID, sessionID, deviceID, kDevice, clientID,
                     kContent, kEnc, kMacS, kMacC, resp, oldPolicy)@i1 &
     LMovieKey(title, movie, ottID, keyID, kContent)@i2
   ==>
    (Ex #j rID kOTT.
        #j < #i1 &
        LOTTRefreshResponse(rID, ottID, kOTT, requestID,
                            kContent, kEnc, kMacS, kMacC, resp)@#j)"
                            simplify
solve( CDMContentKey( ~requestID, ~sessionID, ~deviceID, keyID,
                      ~kContent, usage, oldPolicy, %t2, xdelta, %counter
       ) ▶₄ #i1 )
  case CDMGenerateRefreshRequest
  solve( CDMKeys( ~requestID, ~sessionID, ~deviceID, kEnc, kMacS,
                  kMacC
         ) ▶₃ #i1 )
    case CDMDerive
    by sorry
  next
    case CDMGenerateRefreshRequest
    solve( CDMKeys( ~requestID, ~sessionID, ~deviceID, kEnc, kMacS,
                    kMacC
           ) ▶₃ #vr )
      case CDMDerive
      solve( CDMKeys( ~requestID, ~sessionID, ~deviceID, xundef1,
                      xundef2, xundef3
             ) ▶₂ #vr.8 )
        case CDMDerive
        by sorry
      next
        case CDMGenerateRequest
        by sorry
      next
        case CDMLoad
        solve( CDMKeys( ~requestID, ~sessionID, ~deviceID, xundef1,
                        xundef2, xundef3
               ) ▶₄ #vr.9 )
          case CDMDerive
          solve( !KU( aenc(kSession, pk(~kDevice.1)) ) @ #vk.18 )
            case OTTLicenseResponse
            by sorry
          next
            case c_aenc
            solve( !KU( hmac(<'renewTag', ~requestID, %t1Recv, %t2Recv, 
                              (%counter%+%x), new_licencePolicy, %delta>,
                             KDF(<
                                  <'S', 'authentication', ~requestID, ~keyID, %t1.1, 
                                   enc(<'clientID', $serialNumber, pk(~kDevice.1), 
                                        sign(<'device', pk(~kDevice.1)>, ~kSign), pk(~kSign), 
                                        sign(<'root', pk(~kSign)>, ~rootCert), $clientInfo>,
                                       ~kPrivacy), 
                                   aenc(~kPrivacy, pk(~kOTT)), ~nonce>, 
                                  kSession>))
                   ) @ #vk.14 )
              case OTTRefreshResponse_case_1
              by contradiction /* from formulas */
            next
              case OTTRefreshResponse_case_2
              by contradiction /* from formulas */
            next
              case OTTRefreshResponse_case_3
              by contradiction /* from formulas */
            next
              case OTTRefreshResponse_case_4
              by contradiction /* from formulas */
            next
              case c_hmac
              solve( !KU( KDF(<
                               <'S', 'authentication', ~requestID, ~keyID, %t1.1, 
                                enc(<'clientID', $serialNumber, pk(~kDevice.1), 
                                     sign(<'device', pk(~kDevice.1)>, ~kSign), pk(~kSign), 
                                     sign(<'root', pk(~kSign)>, ~rootCert), $clientInfo>,
                                    ~kPrivacy), 
                                aenc(~kPrivacy, pk(~kOTT)), ~nonce>, 
                               kSession>)
                     ) @ #vk.34 )
                case c_KDF
                solve( !KU( enc(kContent.1,
                                KDF(<
                                     <'encryption', ~requestID, ~keyID, %t1.1, 
                                      enc(<'clientID', $serialNumber, pk(~kDevice.1), 
                                           sign(<'device', pk(~kDevice.1)>, ~kSign), pk(~kSign), 
                                           sign(<'root', pk(~kSign)>, ~rootCert), $clientInfo>,
                                          ~kPrivacy), 
                                      aenc(~kPrivacy, pk(~kOTT)), ~nonce>, 
                                     kSession.1>))
                       ) @ #vk.32 )
                  case OTTLicenseResponse
                  solve( !KU( hmac(<'loadTag', ~requestID, %t1.1, %delta.1, 
                                    licencePolicy, keyID.2, 
                                    enc(~kContent,
                                        KDF(<
                                             <'encryption', ~requestID, ~keyID, %t1.1, 
                                              enc(<'clientID', $serialNumber, pk(~kDevice.1), 
                                                   sign(<'device', pk(~kDevice.1)>, ~kSign), 
                                                   pk(~kSign), 
                                                   sign(<'root', pk(~kSign)>, ~rootCert), 
                                                   $clientInfo>,
                                                  ~kPrivacy), 
                                              aenc(~kPrivacy, pk(~kOTT)), ~nonce>, 
                                             ~kSession.1>)), 
                                    enc(<%deltaBis, usage.1, ~nonce>, ~kContent)>,
                                   KDF(<
                                        <'S', 'authentication', ~requestID, ~keyID, %t1.1, 
                                         enc(<'clientID', $serialNumber, pk(~kDevice.1), 
                                              sign(<'device', pk(~kDevice.1)>, ~kSign), pk(~kSign), 
                                              sign(<'root', pk(~kSign)>, ~rootCert), $clientInfo>,
                                             ~kPrivacy), 
                                         aenc(~kPrivacy, pk(~kOTT)), ~nonce>, 
                                        ~kSession.1>))
                         ) @ #vk.36 )
                    case OTTLicenseResponse
                    solve( !KU( sign(<'newreqTag', ~requestID, ~keyID, %t1.1, 
                                      enc(<'clientID', $serialNumber, pk(~kDevice.1), 
                                           sign(<'device', pk(~kDevice.1)>, ~kSign), pk(~kSign), 
                                           sign(<'root', pk(~kSign)>, ~rootCert), $clientInfo>,
                                          ~kPrivacy), 
                                      aenc(~kPrivacy, pk(~kOTT)), ~nonce>,
                                     ~kDevice.1)
                           ) @ #vk.49 )
                      case CDMGenerateRequest
                      solve( !KU( enc(<%deltaBis, 'use', ~nonce>, ~kContent) ) @ #vk.38 )
                        case OTTLicenseResponse
                        solve( ($newlicence = 'renewable')  ∥ ($newlicence = 'stop') )
                          case case_1
                          solve( !CDMSession( ~sessionID, ~deviceID, kDevice, clientID
                                 ) ▶₁ #i1 )
                            case CDMOpenSession
                            solve( !CDMState( ~requestID, ~sessionID, ~deviceID, $ottID,
                                              ~pkOTT, request, %t1
                                   ) ▶₂ #i1 )
                              case CDMGenerateRequest
                              solve( !KU( ~requestID ) @ #vk.17 )
                                case CDMGenerateRefreshRequest
                                by contradiction /* cyclic */
                              next
                                case CDMGenerateRequest_case_1
                                solve( !KU( ~keyID ) @ #vk.35 )
                                  case GenMovieKeys
                                  solve( !KU( ~nonce ) @ #vk.49 )
                                    case CDMGenerateRequest
                                    solve( !KU( aenc(~kSession.1, pk(~kDevice)) ) @ #vk.40 )
                                      case OTTLicenseResponse
                                      solve( !KU( pk(~kDevice) ) @ #vk.44 )
                                        case CDMGenerateRefreshRequest_case_1
                                        simplify
                                        by contradiction /* cyclic */
                                      next
                                        case CDMGenerateRefreshRequest_case_2
                                        simplify
                                        by contradiction /* cyclic */
                                      next
                                        case CDMGenerateRequest_case_1
                                        by sorry
                                      next
                                        case CDMGenerateRequest_case_2
                                        by sorry
                                      next
                                        case GenDeviceKey_case_1
                                        solve( !KU( enc(<'clientID', $serialNumber, pk(~kDevice), 
                                                         sign(<'device', pk(~kDevice)>, ~kSign), 
                                                         pk(~kSign), 
                                                         sign(<'root', pk(~kSign)>, ~rootCert), 
                                                         $clientInfo>,
                                                        ~kPrivacy)
                                               ) @ #vk.48 )
                                          case CDMGenerateRequest
                                          solve( !KU( aenc(~kPrivacy, pk(~kOTT)) ) @ #vk.49 )
                                            case CDMGenerateRequest
                                            solve( CDMContentKey( ~requestID, ~sessionID, ~deviceID,
                                                                  keyID.1, ~kContent, usage,
                                                                  'renewable', %t2, %xdelta,
                                                                  %counter
                                                   ) ▶₅ #vr )
                                              case CDMLoad
                                              solve( CDMContentKey( ~requestID, ~sessionID,
                                                                    ~deviceID, xkeyID, xkContent,
                                                                    xusage, xpolicy, xt, xdelta1,
                                                                    %counter
                                                     ) ▶₅ #vr.9 )
                                                case CDMGenerateRequest
                                                solve( CDMKeys( ~requestID, ~sessionID, ~deviceID,
                                                                xundef1, xundef2, xundef3
                                                       ) ▶₂ #vr.10 )
                                                  case CDMDerive
                                                  by sorry
                                                next
                                                  case CDMGenerateRequest
                                                  solve( %t1 ⊏ %t.1 )
                                                    case SubtermSplit1
                                                    solve( (%newVar%+%t1) ⊏ %t )
                                                      case SubtermSplit1
                                                      solve( %t1 ⊏ %t )
                                                        case SubtermSplit1
                                                        solve( (%t1%+%newVar.2) ⊏ (%newVar%+%t1%+
                                                                                   %newVar.1) )
                                                          case SubtermSplit1_case_1
                                                          by contradiction
                                                             /* contradictory subterm store */
                                                        next
                                                          case SubtermSplit1_case_2
                                                          by contradiction
                                                             /* contradictory subterm store */
                                                        next
                                                          case SubtermSplit1_case_3
                                                          by sorry
                                                        next
                                                          case SubtermSplit1_case_4
                                                          by sorry
                                                        next
                                                          case SubtermSplit1_case_5
                                                          SOLVED // trace found
                                                        next
                                                          case SubtermSplit1_case_6
                                                          by sorry
                                                        next
                                                          case SubtermSplit1_case_7
                                                          by sorry
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                next
                                                  case CDMLoadRefresh
                                                  by contradiction /* cyclic */
                                                qed
                                              qed
                                            qed
                                          next
                                            case c_aenc
                                            by sorry
                                          qed
                                        next
                                          case c_enc
                                          by sorry
                                        qed
                                      next
                                        case GenDeviceKey_case_2
                                        by sorry
                                      next
                                        case c_pk
                                        by contradiction /* from formulas */
                                      qed
                                    next
                                      case c_aenc
                                      by contradiction /* from formulas */
                                    qed
                                  qed
                                next
                                  case OTTInit
                                  by sorry
                                qed
                              next
                                case CDMGenerateRequest_case_2
                                by sorry
                              qed
                            qed
                          qed
                        next
                          case case_2
                          by sorry
                        qed
                      next
                        case c_enc
                        by contradiction /* from formulas */
                      qed
                    next
                      case c_sign
                      by contradiction /* from formulas */
                    qed
                  next
                    case c_hmac
                    by sorry
                  qed
                next
                  case c_enc
                  by sorry
                qed
              qed
            qed
          qed
        next
          case CDMGenerateRequest
          by sorry
        next
          case CDMLoadRefresh
          by contradiction /* cyclic */
        qed
      next
        case CDMLoadRefresh
        by contradiction /* cyclic */
      qed
    next
      case CDMGenerateRequest
      by sorry
    next
      case CDMLoad
      by sorry
    next
      case CDMLoadRefresh
      by contradiction /* cyclic */
    qed
  next
    case CDMGenerateRequest
    by contradiction /* cyclic */
  next
    case CDMLoad
    simplify
    by contradiction /* cyclic */
  next
    case CDMLoadRefresh
    by contradiction /* cyclic */
  qed
next
  case CDMLoad
  by sorry
qed


/* ------------------------------------------- */
/* Extra Goal 8 - Load Refresh only when authorised */
/* does not hold, due to the attack on Goal 5  */

/* Only one request for each session */
/* as mentioned in the new standard draft - December 2023 */
/* This restriction is needed to establish e.g. Goal 8 */
restriction GenerateRequestUniquePerSession:
  "All #i1 requestID1 sessionID deviceID1 t1
       #i2 requestID2 deviceID2 t2.
     LCDMGenerateRequest(requestID1, sessionID, deviceID1, t1)@#i1 &
     LCDMGenerateRequest(requestID2, sessionID, deviceID2, t2)@#i2 
    ==>
     #i1 = #i2"

/* Only one load succeeds for each requestID */
/* A priori only required to establish Goal 8 */
lemma LoadUnique[reuse]:
  "All requestID sessionID deviceID
       #i1 kDevice  clientID  kContent  kEnc  kMacS  kMacC  response
       #i2 kDevice2 clientID2 kContent2 kEnc2 kMacS2 kMacC2 response2.
    LCDMLoad(requestID, sessionID, deviceID, kDevice,  clientID,  kContent,
             kEnc,  kMacS,  kMacC,  response )@i1 &
    LCDMLoad(requestID, sessionID, deviceID, kDevice2, clientID2, kContent2,
             kEnc2, kMacS2, kMacC2, response2)@i2
   ==>
    #i1 = #i2"



/* This lemma is the extra Goal 8 -- it does not hold, due to the attack on Goal 5 */
lemma LoadRefreshOnlyIfRenewable:
  "All #i1 requestID sessionID deviceID kDevice clientID
           kContent kEnc kMacS kMacC response oldPolicy
       #i2 title movie ottID keyID.
     LCDMLoadRefresh(requestID, sessionID, deviceID, kDevice, clientID,
                     kContent, kEnc, kMacS, kMacC, response, oldPolicy)@i1 &
     LMovieKey(title, movie, ottID, keyID, kContent)@i2
   ==>
     oldPolicy = 'renewable' "



/* ------------------------------------------ */
/* Goal 7                                     */
/* does not hold, due to the attack on Goal 5 */
lemma UseAuthorised:
  "All #i requestID sessionID deviceID keyID kContent %t
       #i2 title movie ottID
       #j sessionIDBis deviceIDBis kDeviceBis clientIDBis kContentBis
          kEncBis kMacSBis kMacCBis renewal_responseBis oldPolicy.
     LCDMUseKey(requestID, sessionID, deviceID, keyID, kContent)@i &
     LCDMLoadRefresh(requestID, sessionIDBis, deviceIDBis, kDeviceBis,
                     clientIDBis, kContentBis, kEncBis, kMacSBis, kMacCBis,
                     renewal_responseBis, oldPolicy)@j &
     (#j < #i | #j=#i) &
     GTime(%t)@i &
     LMovieKey(title, movie, ottID, keyID, kContent)@i2
    ==>
     (Ex #j %t1 %delta.
         LOTTAuthorise(requestID, ottID, %t1, %delta)@j &
         #j < #i &
         %t << %t1 %+ %delta)"

#endif


/*-------------------------------------------------------------------*/
/* Lemma: Executability                                              */
/*-------------------------------------------------------------------*/
#ifdef Executability

/*-------------------------------------------------------------------*/
/* First some restrictions to reduce the search space when looking for
   the executability witness. Sound, since we still find a witness. */
   

/* Rule GenDeviceSignKey is called at most once */
restriction onlyOnceDeviceSignKey:
  "All #i1 kSign1 #i2 kSign2.
     LDeviceSignKey(kSign1)@i1 &
     LDeviceSignKey(kSign2)@i2
   ==>
     #i1 = #i2" 

/* Rule GenDeviceKey is called at most once */
restriction onlyOnceDeviceKey:
  "All #i1 kDevice1 #i2 kDevice2.
     LDeviceKey(kDevice1)@i1 &
     LDeviceKey(kDevice2)@i2
   ==>
     #i1 = #i2" 

/* Rule GenOTTKey is called at most once */
restriction onlyOnceOTTKey:
  "All #i1 kOTT1 #i2 kOTT2.
     LOTTKey(kOTT1)@i1 &
     LOTTKey(kOTT2)@i2
   ==>
     #i1 = #i2"

/* Rule GenMovieKeys is called at most once */
restriction onlyOnceMovie:
  "All #i1 title1 movie1 ottID1 keyID1 kContent1
       #i2 title2 movie2 ottID2 keyID2 kContent2.
     LMovieKey(title1, movie1, ottID1, keyID1, kContent1)@i1 &
     LMovieKey(title2, movie2, ottID2, keyID2, kContent2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMInit is called at most once */
restriction onlyOnceCDMInit:
  "All #i1 deviceID1 kDevice1 clientID1
       #i2 deviceID2 kDevice2 clientID2. 
    LCDMInit(deviceID1, kDevice1, clientID1)@i1 &
    LCDMInit(deviceID2, kDevice2, clientID2)@i2
  ==>
    #i1 = #i2"

/* Rule CDMOpenSession is called at most once */
restriction onlyOnceOpenSession:
  "All #i1 deviceID1 sessionID1 kDevice1
       #i2 deviceID2 sessionID2 kDevice2.
     LCDMOpenSession(sessionID1, deviceID1, kDevice1)@i1 &
     LCDMOpenSession(sessionID2, deviceID2, kDevice2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMGenerateRequest/CDMGenerateRSASignature is called at most once */
restriction onlyOnceCDMGenerateRequest:
  "All #i1 deviceID1 sessionID1 requestID1 t1
       #i2 deviceID2 sessionID2 requestID2 t2.
     LCDMGenerateRequest(requestID1, sessionID1, deviceID1, t1)@i1 &
     LCDMGenerateRequest(requestID2, sessionID2, deviceID2, t2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMDerive/CDMDeriveLow is called at most once */
restriction onlyOnceCDMDerive:
  "All #i1 deviceID1 kDevice1 clientID1 sessionID1 kEnc1 kMacS1 kMacC1
           requestID1 
       #i2 deviceID2 kDevice2 clientID2 sessionID2 kEnc2 kMacS2 kMacC2
           requestID2. 
     LCDMDerive(requestID1, sessionID1, deviceID1, kDevice1, clientID1,
                kEnc1, kMacS1, kMacC1)@i1 &
     LCDMDerive(requestID2, sessionID2,  deviceID2, kDevice2, clientID2,
                kEnc2, kMacS2, kMacC2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMLoad/CDMLoadLow is called at most once */
restriction onlyOnceCDMLoad:
  "All #i1 deviceID1 kDevice1 clientID1 requestID1 sessionID1 kContent1
           kEnc1 kMacS1 kMacC1 response1 
       #i2 deviceID2 kDevice2 clientID2 requestID2 sessionID2 kContent2
           kEnc2 kMacS2 kMacC2 response2. 
     LCDMLoad(requestID1, sessionID1, deviceID1, kDevice1, clientID1,
              kContent1, kEnc1, kMacS1, kMacC1, response1)@i1 &
     LCDMLoad(requestID2, sessionID2, deviceID2, kDevice2, clientID2,
              kContent2, kEnc2, kMacS2, kMacC2, response2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMGenerateRefresh/CDMGenerateSignature is called at most once */
restriction onlyOnceCDMGenerateRefreshRequest:
  "All #i1 deviceID1 sessionID1 requestID1 t1 kEnc1 kMacS1 kMacC1 
       #i2 deviceID2 sessionID2 requestID2 t2 kEnc2 kMacS2 kMacC2.
     LCDMGenerateRefreshRequest(requestID1, sessionID1, deviceID1, t1,
                                kEnc1, kMacS1, kMacC1)@i1 &
     LCDMGenerateRefreshRequest(requestID2, sessionID2, deviceID2, t2,
                                kEnc2, kMacS2, kMacC2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMLoadRefresh/CDMLoadRefreshLow is called at most once */
restriction onlyOnceCDMLoadRefresh:
  "All #i1 deviceID1 kDevice1 clientID1 requestID1 sessionID1
           kContent1 kEnc1 kMacS1 kMacC1 rr1 oldPolicy1
       #i2 deviceID2 kDevice2 clientID2 requestID2 sessionID2
           kContent2 kEnc2 kMacS2 kMacC2 rr2 oldPolicy2.
     LCDMLoadRefresh(requestID1, sessionID1, deviceID1, kDevice1, clientID1,
                     kContent1, kEnc1, kMacS1, kMacC1, rr1, oldPolicy1)@i1 &
     LCDMLoadRefresh(requestID2, sessionID2, deviceID2, kDevice2, clientID2,
                     kContent2, kEnc2, kMacS2, kMacC2, rr2, oldPolicy2)@i2
   ==>
     #i1 = #i2"

/* Rule CDMUseKey is not used */
restriction noCDMUseKey:
  "All #i requestID sessionID deviceID keyID kContent.
     LCDMUseKey(requestID, sessionID, deviceID, keyID, kContent)@i
   ==>
     not(#i = #i)"

/* Rule InitOTT is called at most once */
restriction onlyOnceOTTInit:
  "All #i1 rID1 ottID1 kOTT1
       #i2 rID2 ottID2 kOTT2. 
     LOTTInit(rID1, ottID1, kOTT1)@i1 &
     LOTTInit(rID2, ottID2, kOTT2)@i2
   ==>
     #i1 = #i2"

/* Rule OTTLicenceResponse is called at most once */
restriction onlyOnceOTTLicenseResponse:
  "All #i1 rID1 ottID1 kOTT1 requestID1 kContent1
           kEnc1 kMacS1 kMacC1 response1 
       #i2 rID2 ottID2 kOTT2 requestID2 kContent2
           kEnc2 kMacS2 kMacC2 response2.
     LOTTLicenseResponse(rID1, ottID1, kOTT1, requestID1,
                         kContent1,  kEnc1, kMacS1, kMacC1, response1)@i1 &
     LOTTLicenseResponse(rID2, ottID2, kOTT2, requestID2,
                         kContent2,  kEnc2, kMacS2, kMacC2, response2)@i2
   ==>
     #i1 = #i2"

/* Rule OTTRefreshResponse is called at most once */
restriction onlyOnceOTTRefreshResponse:
  "All #i1 rID1 ottID1 kOTT1 requestID1 kContent1 kEnc1 kMacS1 kMacC1 resp1
       #i2 rID2 ottID2 kOTT2 requestID2 kContent2 kEnc2 kMacS2 kMacC2 resp2.
     LOTTRefreshResponse(rID1, ottID1, kOTT1, requestID1,
                         kContent1,  kEnc1, kMacS1, kMacC1, resp1)@i1 &
     LOTTRefreshResponse(rID2, ottID2, kOTT2, requestID2,
                         kContent2,  kEnc2, kMacS2, kMacC2, resp2)@i2
   ==>
     #i1 = #i2"

/* Executability lemma */
lemma exec:
  exists-trace
  "Ex #i1 #i2 #i3  #i5 #i6 #i7 #i8 #i9
      kOTT deviceID kDevice clientID
      sessionID requestID rID ottID 
      kContent kEnc kMacS kMacC response renewal_response oldPolicy t1. 
    (LCDMLoadRefresh(requestID, sessionID, deviceID, kDevice, clientID,
                     kContent, kEnc, kMacS, kMacC,
                     renewal_response, oldPolicy)@i1 &
     LOTTRefreshResponse(rID, ottID, kOTT, requestID, kContent,
                         kEnc, kMacS, kMacC, renewal_response)@i2 &
     LCDMGenerateRefreshRequest(requestID, sessionID, deviceID,
                                t1, kEnc, kMacS, kMacC)@i3 &
     LCDMLoad(requestID, sessionID, deviceID, kDevice, clientID,
              kContent, kEnc, kMacS, kMacC, response)@i5 &
     LCDMDerive(requestID, sessionID, deviceID, kDevice, clientID,
                kEnc, kMacS, kMacC)@i6 &
     LOTTLicenseResponse(rID, ottID, kOTT, requestID, kContent,
                         kEnc, kMacS, kMacC, response)@i7 &
     LCDMGenerateRequest(requestID, sessionID, deviceID, t1)@i8 &
     LCDMOpenSession(sessionID, deviceID, kDevice)@i9 &
     #i9 < #i8 & #i8 < #i7 & #i7 < #i6 &
     #i6 < #i5 & #i5  <#i3 &
     #i3 < #i2 & #i2 < #i1)"


#endif


end




